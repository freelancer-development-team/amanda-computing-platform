/* Parser to convert "C" assignments to lisp using Bison in C. */
/* Demonstrates Bison C++ interface with %skeleton "lalr1.cc" */
/* Compile: bison -d flexexample9.yxx */

%require  "3.0"
%skeleton "lalr1.cc"

%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }
  class Driver;   /* Defined below */
}

%defines

%locations

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { Driver& driver }    /* Construct parser object with driver (optional) */

%code{
  #include "lex.yy.h"

  #undef yylex
  #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */

  class Driver {
   public:
    Driver(reflex::Input in) : lexer(in), parser(new yy::parser(lexer, *this)) { }
    ~Driver() { delete parser; }
    int parse() { return parser->parse(); }
   private:
    yy::Lexer   lexer;
    yy::parser *parser;
  };
}

%union {
    int   num;
    char *str;
}

%token <str> STRING
%token <num> NUMBER

%%

assignments : assignment
            | assignment assignments
            ;
assignment  : STRING '=' NUMBER ';' { std::cout << "(setf " << $1 << " " << $3 << ")\n"; }
            ;

%%

int main()
{
  Driver driver(std::cin);
  return driver.parse();
}

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  std::cerr << msg << " at " << loc << std::endl;
}
