%{
/*
 * Copyright (C) 2022 FreeLancer Development Team
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/// This file contains the lexical specification for the Amanda Programming
/// Language.
///
/// This lexer specification is made to work with the Bison 3.2(+) C++ generated
/// parser. Keep this in mind when introducing changes to the lexical
/// specification.
/// This specification is not fully Flex compatible, and it is intented to be
/// used as input to the RE/Flex scanner.
///

// C Standard Library
#include <cstdlib>
#include <cstdio>

// Compiler APIs
#include <amanda-c/Messages.h>
#include <amanda-vm/TypeSystem.h>

%}

%top{
    #include <amanda-c/Parser.h>            // Generated by Bison 3.2(+)
    #include <amanda-c/ParserLocations.h>   // Generated by Bison 3.2(+)
}

// Enable free-space mode in order to improve readability
%option freespace

// Scanner optimization level
%option fast

// Scanner class: amanda::compiler::Scanner
%option namespace=amanda::compiler
%option lexer=Scanner

// Scanner errors

// Bison 3.2(+) parser integration:
%option bison-complete
%option bison-locations
%option bison-cc-namespace=amanda::compiler
%option bison-cc-parser=DefaultParser

// Scanner class
%class{
    public:

        typedef DefaultParser::token    Tokens;

    protected:

        typedef struct Keyword
        {
            const char* name;
            int token;
        } Keyword;

    int getKeyWordToken(const char* str)
    {
        #define TOKEN(x)    DefaultParser::token::TOKEN_ ## x

        int result = 0;

        static const Keyword kwds[] =
        {
            { "break",      TOKEN(BREAK)        },
            { "case",       TOKEN(CASE)         },
            { "class",      TOKEN(CLASS)        },
            { "do",         TOKEN(DO)           },
            { "else",       TOKEN(ELSE)         },
            { "for",        TOKEN(FOR)          },
            { "if",         TOKEN(IF)           },
            { "interface",  TOKEN(INTERFACE)    },
            { "namespace",  TOKEN(NAMESPACE)    },
            { "switch",     TOKEN(SWITCH)       },
            { "return",     TOKEN(RETURN)       },
            { "using",      TOKEN(USING)        },
            { "while",      TOKEN(WHILE)        },
            // Data types
            { "void",       TOKEN(VOID) },
            { "bool",       TOKEN(BOOL) },
            { "int",        TOKEN(INT) },
            { "long",       TOKEN(LONG) },
            { "string",     TOKEN(STRING) },
            { "char",       TOKEN(CHAR) },
            { "float",      TOKEN(FLOAT) },
            { "double",     TOKEN(DOUBLE) },
            { NULL, 0 }
        };

        for (const Keyword* kwd = &kwds[0]; kwd->name != NULL; ++kwd)
        {
            if (::strcmp(kwd->name, str) == 0)
            {
                result = kwd->token;
                break;
            }
        }

        #undef TOKEN

        return result;
    }

    DefaultParser::symbol_type token(int id)
    {
        return DefaultParser::symbol_type(id, location());
    }

    DefaultParser::symbol_type integerLiteral()
    {
        return DefaultParser::make_INTEGER(text(), location());
    }

    void scannerException();
}

// Character classes
digit                           [0-9]
alpha                           [A-Za-z_]
identifier                      {alpha} ( {alpha} | {digit} )*

decimal_integer                 [+-]? {digit}+

integer_literal                 {decimal_integer}

%%

[[:space:]]+                    // skip white space
"#".*                           // ignore inline comment
"/*"(.|\n)*?"*/"                // ignore multi-line comment using a lazy regex pattern

{identifier}                    {   int token = getKeyWordToken(text());
                                    return token ?
                                            DefaultParser::symbol_type(token, location())
                                        :   DefaultParser::make_IDENTIFIER(amanda::core::String(text()), location());
                                }
{integer_literal}               { return integerLiteral(); }

"{"                             { return token('{'); }
"}"                             { return token('}'); }
"("                             { return token('('); }
")"                             { return token(')'); }
"["                             { return token('['); }
"]"                             { return token(']'); }

":"                             { return token(':'); }
","                             { return token(','); }
";"                             { return token(';'); }
"."                             { return token('.'); }
"::"                            { return token(Tokens::TOKEN_SCOPE_OP); }

"<="                            { return token(Tokens::TOKEN_LE); }
">="                            { return token(Tokens::TOKEN_GE); }
">"                             { return token('>'); }
"<"                             { return token('<'); }
"=="                            { return token(Tokens::TOKEN_EQ); }
"!="                            { return token(Tokens::TOKEN_NEQ); }

"="                             { return token('='); }
"++"                            { return token(Tokens::TOKEN_PLUSPLUS); }
"--"                            { return token(Tokens::TOKEN_MINUSMINUS); }

"+"                             { return token('+'); }
"-"                             { return token('-'); }
"/"                             { return token('/'); }
"*"                             { return token('*'); }
"%"                             { return token('%'); }
"&"                             { return token('&'); }
"|"                             { return token('|'); }
"~"                             { return token('~'); }
"^"                             { return token('^'); }

<<EOF>>                         { return DefaultParser::make_EOF(location()); }
.                               { scannerException(); }

%%

#include <amanda-c/ParserLocations.h>
#include <amanda-vm/Frontend/LexerException.h>

namespace amanda
{
namespace compiler
{

void Scanner::scannerException()
{
    const amanda::compiler::location& loc = location();

    int l_begin = loc.begin.line;
    int l_end = loc.end.line;
    int c_begin = loc.begin.column;
    int c_end = loc.end.column;

    log::error("%s:%d:%d: unrecognized token: '%s'. (from %d:%d to %d:%d)",
                loc.begin.filename->c_str(),
                l_begin, c_begin,
                text(), l_begin, c_begin, l_end, c_end);

    throw amanda::frontend::LexerException();
}

}
}
